// Attack should be handled off-chain, preferably by EOA
// See sherlock.test.ts file for solution

// This on-chain solution has precomputed correct answer
// It's purpose is to adhere to CTF's interface

pragma solidity 0.8.4;

interface IChallenge {
    function createContract(bytes memory bytecode, uint salt) external;
}

interface ISetup {
    function isSolved() external view returns (bool);
}

contract Exploit {
    address challenge;
    address setup;


    constructor(address _challenge, address _setup) {
        challenge = _challenge;
        setup = _setup;

        bytes memory bytecode = hex'608060405234801561001057600080fd5b5060ff8061001f6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80632d2927e314602d575b600080fd5b60336035565b005b6000808154809291906045906056565b9190505550565b6000819050919050565b6000605f82604c565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415608f57608e609a565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea26469706673582212202dd8f946c86b039bf8ab0fff75a9e79926858f282f784a8f54c1c5b99c8652a764736f6c63430008040033';
        uint256 salt = 23167279743460724461247717006863355784470130553221099219428282400133720571904;

        IChallenge(challenge).createContract(bytecode, salt);

        require(ISetup(setup).isSolved(), "Exploit failed");
    }
}